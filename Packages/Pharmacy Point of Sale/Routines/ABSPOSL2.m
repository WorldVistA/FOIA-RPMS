ABSPOSL2 ; IHS/OIT/RAM ;  NEW LOGGING FACILITY SYSTEM ;  [ 7 JUN 2017  9:37 AM ]
 ;;1.0;PHARMACY POINT OF SALE;**48**;7 JUN 2017;Build 38
 ;---
 Q  ; NOT THE ENTRY POINT... YET.
 ; /IHS/OIT/RAM ; 7 JUN 2017 ;
 ; ISSUE: MANY (MOST?) FILEMAN DBS CALLS DISALLOW OR IGNORE ANY ERROR PARAMETER.
 ;        I AIM TO FIX THAT. NEED A FUNCTION THAT WILL SAVE THE LAST 20 OR SO
 ;        DBS CALLS (FILE^DIE & UPDATE^DIE, MAINLY), AND STORE THE ERROR IN A
 ;        GLOBAL AND/OR FILEMAN TABLE.  [[ GLOBAL IF DISALLOWED TO CREATE NEW TABLES WITHOUT DBA'S HELP. ]]
 ;
LOG(ROUTINE,ERROR) ; /IHS/OIT/RAM ; 7 JUN 2017 ; NEW FM DBS CALL LOGGING
 ;;1.0;PHARMACY POINT OF SALE;**48**;7 JUN 2017
 ;
 ; PRETTY SIMPLE ROUTINE HERE -- KEEP THE LAST 'LOGLENGTH' DBS CALL ERRORS.
 ; ROUTINE SHOULDN'T BE CALLED UNLESS THERE *ACTUALLY* IS AN ERROR; I SHALL
 ;   LEAVE IT UP TO THE CALLING PROCESS TO DETERMINE IF AN ERROR EXISTS.
 ; 
 ; INPUT VARIABLES:
 ;   ROUTINE == TEXT FIELD CONTAINING THE SUB^ROUTINE THAT CALLED US. NOT CHECKED FOR ACCURACY, JUST FILED.
 ;   ERROR == ARRAY THAT CONTAINS THE 'DIERR' INFORMATION TO BE FILED.
 ;
 N I,I2,I3,J,J2,J3,K,K2,K3,X,Y,%,NOW
 N LOGLENGTH,L2FDA,L2ERR,L2FDAIEN,NUMERRS,ERRNUM
 ;
 S NUMERRS=+$G(ERROR("DIERR")) ; LET'S FIND OUT HOW MANY ERRORS WE HAVE TO LOG.
 Q:NUMERRS=0 ;; IF THERE'S NO ERRORS PASSED TO US (FOR SOME REASON) EXIT QUIETLY.
 ;
 S LOGLENGTH=30  ; MAXIMUM NUMBER OF ENTRIES IN TABLE; WE DON'T WANT THIS LOG TO GROW TOO LARGE.
 D NOW^%DTC S NOW=%  ; LOG ERRORS BY DATE/TIME THAT THIS UTILITY WAS CALLED.
 ;                   THERE IS A SMALL POSSIBILITY OF LOST DATA IF THIS ROUTINE GETS CALLED TWICE IN THE SAME SECOND.
 ;  =-=-=-=
 ; FIRST, DETERMINE THEN NUMBER OF ERRORS IN THE LOG. MORE THAN 'LOGLENGTH' ERRORS,
 ;    DELETE THE OLDEST. AS THE IEN IS FILEMAN DTG OF TIME OF CALL, JUST KILL THE 1ST ONE(S)...
 ;
 S (I,I2,I3)=0 F  S I=$O(^ABSPFMLOG(I)) Q:+I=0  S I2=I2+1 ; INITIALIZE VARIABLES AND LOOP TO COUNT LOG ENTRY #.
 I I2>(LOGLENGTH-1) { 
  S I=0 K L2FDA,L2ERR,ERRNUM  ;; INITIALIZE DBS CALL VARIABLES. MAKE SURE WE USE DIFFERENT VARIABLE NAMES
  F I3=1:1:I2-(LOGLENGTH-1) {   ;; LOOP THROUGH THE # OF LOGS OVER LOGLENGTH -- EXCEPTING THE ONE WE'RE ABOUT TO ADD.
 	 S I=$O(^ABSPFMLOG(I))     ;; AND GET THE IEN OF EACH LOG ENTRY TO BE DELETED.
 	                       ;; THAN ORIGINAL CALLING ROUTINE TO INSURE WE DON'T OVERWRITE EXISTING DATA.
         ; S L2FDA(9002313.71,I+1_",",.01)="@"  ;; FOR TESTING THE ERROR HANDLING BELOW; KEEP COMMENTED OUT.
         S L2FDA(9002313.71,I_",",.01)="@"      ;; SET THE FDA TO DELETE THE ENTRY
  }
  ;
     D UPDATE^DIE("","L2FDA","","L2ERR")    ;; AND EXECUTE THE DBS CALL TO DELETE.
     ; JUST IN CASE, IF THIS CALL FAILS SET A SINGLE "INTERNAL ERROR" NODE AND GRAB THE ERROR TEXT.
     I $D(L2ERR) S ^ABSPFMLOG("IERR","DELETE",0)=I_U_NOW_U_$G(L2ERR("DIERR",1,"TEXT",1))
     ;
 }
 ;
 K L2FDA,L2ERR,ERRNUM  ;; KLOBBER VARIABLES AGAIN AFTER THE 'DELETE' PHASE ABOVE.
 S L2FDA(9002313.71,"+1,",.01)=NOW    ;; SET UP THE DBS CALL TO ADD A NEW BASE RECORD INTO THE ^ABSPFMLOG FILE.
 ; S L2FDA(9002313.719,"+1,",.01)=NOW ;; FOR TESTING THE ERROR HANDLING BELOW; KEEP COMMENTED OUT.
 S L2FDAIEN(1)=NOW    ;; SET THE IEN TO THE DATE/TIME WE WERE CALLED.
 D UPDATE^DIE("","L2FDA","L2FDAIEN","L2ERR")  ;; AND ADD THE RECORD. 
 I $D(L2ERR) S ^ABSPFMLOG("IERR","LEVEL1",0)=I_U_$G(L2ERR("DIERR",1,"TEXT",1))
 K L2FDA,L2ERR    ;; ONCE AGAIN, KILL THE PREVIOUS VARIABLES FOR THE NEXT CALL BELOW.
 F I=1:1:NUMERRS {    ;; SET UP VARIABLES FOR ALL ERRORS THAT WERE SENT TO US.
  S ERRNUM=$G(ERROR("DIERR",I))  ;; GET THE FILEMAN ERROR NUMBER, COULD BE USEFUL FOR LOOKUP LATER.
  ; S L2FDA(9002313.7119,"+"_I_","_NOW_",",.01)=$G(ROUTINE)_U_ERRNUM_U_$G(ERROR("DIERR",I,"TEXT",1)) ;; FOR TESTING THE ERROR HANDLING BELOW; KEEP COMMENTED OUT.
  S L2FDA(9002313.711,"+"_I_","_NOW_",",.01)=$G(ROUTINE)_U_ERRNUM_U_$G(ERROR("DIERR",I,"TEXT",1))  ; SET UP THE DBS SUBNODE ADD VARIABLES.
  S L2FDAIEN(I)=I  ;; AND SET UP THE DBS SUBNODE IEN INFO.
 }
 D UPDATE^DIE("","L2FDA","L2FDAIEN","L2ERR")  ;;  AND ADD THAT INFO TO THE 'ABSP FILEMAN ERROR LOG' TABLE.
 I $D(L2ERR) S ^ABSPFMLOG("IERR","LEVEL2",0)=I_U_NOW_U_$G(L2ERR("DIERR",1,"TEXT",1))  ;; AND IF THE ABOVE CALL FAILS, SET A BASIC ERROR NODE.
 ;
 Q  ;; YAY! WE'RE DONE -- RETURN TO THE ROUTINE THAT CALLED US.
 ;
CDATA() ;;
 Q 8692
 ;
CHKDATA(VAR1,VAR2) ;;
 M ^BZHZFLERM(1)=@VAR1
 M ^BZHZFLERM(2)=@VAR2
 Q
 ;
